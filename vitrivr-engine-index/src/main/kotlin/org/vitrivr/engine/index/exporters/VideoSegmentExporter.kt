package org.vitrivr.engine.index.exporters

import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.bytedeco.ffmpeg.global.avcodec
import org.bytedeco.ffmpeg.global.avutil
import org.bytedeco.javacpp.PointerScope
import org.bytedeco.javacv.*
import org.vitrivr.engine.core.context.Context
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.model.retrievable.attributes.time.TimeRangeAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.OperatorFactory
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.resolver.Resolvable
import org.vitrivr.engine.core.resolver.Resolver
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.Source
import org.vitrivr.engine.core.source.file.FileSource
import org.vitrivr.engine.core.source.file.MimeType
import java.io.ByteArrayOutputStream
import java.util.*
import kotlin.text.lowercase
import kotlin.text.uppercase


private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates cropped video file for each video segment.
 *
 * @author Raphael Waltensp√ºl
 * @version 1.1.0
 */
class VideoSegmentExporter : OperatorFactory {

    companion object {
        val SUPPORTED = setOf(MimeType.MP4)
    }

    /**
     * Creates a new [Instance] instance from this [ThumbnailExporter].
     *
     * @param name the name of the [ThumbnailExporter.Instance]
     * @param inputs Map of named input [Operator]s
     * @param context The [Context] to use.
     */
    override fun newOperator(name: String, inputs: Map<String, Operator<out Retrievable>>, context: Context): Operator<out Retrievable> {
        require(inputs.size == 1)  { "The ${this::class.simpleName} only supports one input operator. If you want to combine multiple inputs, use explicit merge strategies." }
        val mimeType = context[name, "mimeType"]?.let {
            try {
                MimeType.valueOf(it.uppercase())
            } catch (_: java.lang.IllegalArgumentException) {
                null
            }
        } ?: MimeType.MP4
        val video = context[name, "video"]?.let { it.lowercase() == "true" } ?: true
        val audio = context[name, "audio"]?.let { it.lowercase() == "true" } ?: true
        val keyFrames = context[name, "keyFrames"]?.let { it.lowercase() == "true" } ?: false
        val resolverName = context[name, "resolver"] ?: "default"
        return Instance(name, inputs.values.first(), context, mimeType, video, audio, keyFrames, resolverName)
    }

    /** The [Exporter] generated by this [VideoSegmentExporter]. */
    private class Instance(
        override val name: String,
        override val input: Operator<out Retrievable>,
        private val context: Context,
        private val mimeType: MimeType,
        private val video: Boolean = true,
        private val audio: Boolean = true,
        private val keyFrames: Boolean = false,
        private val resolverName: String
    ) : Exporter {

        // To maintain memory usage, only keep one grabber for each source.
        private var grabber: Pair<FFmpegFrameGrabber, UUID>? = null

        init {
            require(mimeType in SUPPORTED) {
                "VideoPreviewExporter only supports image formats ${SUPPORTED.joinToString(", ")}."
            }
        }

        val resolver: Resolver = this.context.resolver[resolverName]
            ?: throw IllegalStateException("Unknown resolver with name $resolverName.")


        override fun toFlow(scope: CoroutineScope): Flow<Retrievable> = this.input.toFlow(scope).onEach { retrievable ->

            val source = retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach
            if (source.type != MediaType.VIDEO || retrievable.type != "SEGMENT") {
                logger.debug { "In flow: Skipping source ${source.name} (${source.sourceId}) because it is not of type VIDEO." }
                return@onEach
            }
            val startTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.startNs!! / 1000
            val endTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.endNs!! / 1000
            val resolvable = resolver.resolve(retrievable.id, this.mimeType.fileExtension)!!


            // Decide `useGrabber` using grabber from source or using content from retrievable
            if (source is FileSource) {
                if (this.grabber == null) {
                    this.grabber = Pair(FFmpegFrameGrabber(source.path.toFile()), source.sourceId)
                }
                if (this.grabber?.second != source.sourceId) {
                    this.grabber?.first?.release()
                    this.grabber?.first?.close()
                    this.grabber = Pair(FFmpegFrameGrabber(source.path.toFile()), source.sourceId)
                }
                decodeFromGrabber(source, resolvable, this.grabber!!.first, startTimestamp, endTimestamp)
            } else {
                if (this.grabber == null) {
                    this.grabber = Pair(FFmpegFrameGrabber(source.newInputStream()), source.sourceId)
                }
                if (this.grabber?.second != source.sourceId) {
                    this.grabber?.first?.release()
                    this.grabber?.first?.close()
                    this.grabber = Pair(FFmpegFrameGrabber(source.newInputStream()), source.sourceId)
                }
                decodeFromGrabber(source, resolvable, this.grabber!!.first, startTimestamp, endTimestamp)
            }
        }

        /**
         * Decodes a video from a [Source] with [FFmpegFrameGrabber] and exports stores it with provided [Resolvable].
         * @param source The [Source] from which the video is being decoded.
         * @param resolvable The [Resolvable] used to store the video.
         * @param grabber The [FFmpegFrameGrabber] used to decode the video.
         * @param startMs The start timestamp of the video segment.
         * @param endMs The end timestamp of the video segment.
         */
        private fun decodeFromGrabber(
            source: Source,
            resolvable: Resolvable,
            grabber: FFmpegFrameGrabber,
            startMs: Long,
            endMs: Long,
        ) {
            /* Configure FFmpegFrameGrabber. */
            grabber.imageMode = FrameGrabber.ImageMode.COLOR
            grabber.sampleMode = FrameGrabber.SampleMode.SHORT


            logger.info { "Start recording segment from ${startMs / 1000000} to ${endMs / 1000000} of source ${source.name} (${source.sourceId})" }
            try {
                grabber.start()
                grabber.setTimestamp(startMs)
                /* Extract and enrich source metadata. */


                val stream: SeekableByteArrayOutputStream = SeekableByteArrayOutputStream()

                val recorder = FFmpegFrameRecorder(
                    stream,
                    grabber.imageWidth,
                    grabber.imageHeight,
                    grabber.audioChannels
                ).apply {
                    format = "mp4"
                }
                try {
                    configureRecorder(recorder, grabber)
                    recorder.start()

                    do {
                        val frame =
                            grabber.grabFrame(
                                this@Instance.audio,
                                this@Instance.video,
                                true,
                                this@Instance.keyFrames,
                                true
                            ) ?: break

                        if (grabber.timestamp >= endMs) {
                            break
                        }

                        when (frame.type) {
                            Frame.Type.VIDEO -> {
                                try {
                                    PointerScope().use { scope -> recorder.record(frame) }
                                } catch (e: Exception) {
                                    logger.error(e) { "Error converting frame to BufferedImage" }
                                }
                            }

                            Frame.Type.AUDIO -> {
                                try {
                                    PointerScope().use { scope -> recorder.record(frame) }
                                } catch (e: Exception) {
                                    logger.error(e) { "Error converting frame to BufferedImage" }
                                }
                            }

                            else -> { /* No op. */
                            }
                        }
                    } while (true)
                } catch (e: Exception) {
                    logger.error(e) { "Error while recording video segment. ${e.cause.toString()}" }
                } finally {
                    recorder.flush()
                    recorder.stop()
                    recorder.close()
                }
                logger.info { "Finished decoding video from source '${source.name}' (${source.sourceId}):" }

                copyStream(stream, resolvable)
            } catch (exception: Exception) {
                logger.error(exception) { "Failed to decode video from source '${source.name}' (${source.sourceId})." }
            } finally {
                grabber.stop()
            }
        }

        private fun copyStream(stream: ByteArrayOutputStream, resolvable: Resolvable) {
            resolvable.openOutputStream().use { output ->
                output.write(stream.toByteArray())
            }
        }


        /**
         * Configures the [FFmpegFrameRecorder] with static values.
         **/
        private fun configureRecorder(recorder: FFmpegFrameRecorder) {
            recorder.format = "mp4"
            recorder.videoCodec = avcodec.AV_CODEC_ID_H264
            recorder.pixelFormat = avutil.AV_PIX_FMT_YUV420P
            recorder.audioCodec = avcodec.AV_CODEC_ID_AAC
        }

        /**
         * Configures the [FFmpegFrameRecorder] with the given [FFmpegFrameGrabber] data.
         **/
        private fun configureRecorder(recorder: FFmpegFrameRecorder, grabber: FFmpegFrameGrabber) {
            configureRecorder(recorder)
            recorder.frameRate = grabber.videoFrameRate
            recorder.videoBitrate = grabber.videoBitrate
            recorder.audioChannels = grabber.audioChannels
            recorder.sampleRate = grabber.sampleRate
            recorder.audioBitrate = grabber.audioBitrate
        }
    }
}