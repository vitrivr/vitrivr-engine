package org.vitrivr.engine.index.exporters

import com.sksamuel.scrimage.ImmutableImage
import com.sksamuel.scrimage.nio.JpegWriter
import com.sksamuel.scrimage.nio.PngWriter
import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.bytedeco.javacpp.PointerScope
import org.bytedeco.javacv.FFmpegFrameGrabber
import org.bytedeco.javacv.Java2DFrameConverter
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.resolver.Resolver
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.file.MimeType
import java.awt.image.BufferedImage
import java.io.InputStream


private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates a single preview of a video at the parameterized timestamp.
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class VideoPreviewExporter : ExporterFactory {
    companion object {
        val SUPPORTED = setOf(MimeType.JPEG, MimeType.JPG, MimeType.PNG)
    }

    /**
     * Creates a new [Exporter] instance from this [VideoPreviewExporter].
     *
     * @param name The name of the [Exporter]
     * @param input The [Operator] to acting as an input.
     * @param context The [Context] to use.
     */
    override fun newExporter(
        name: String,
        input: Operator<Retrievable>,
        parameters: Map<String, String>,
        context: Context
    ): Exporter {
        val resolverName = parameters["resolver"] ?: "default"
        val maxSideResolution = parameters["maxSideResolution"]?.toIntOrNull() ?: 400
        val mimeType =
            parameters["mimeType"]?.let {
                try {
                    MimeType.valueOf(it.uppercase())
                } catch (e: java.lang.IllegalArgumentException) {
                    null
                }
            } ?: MimeType.JPG
        val previewTimeSec = parameters["previewTimeSec"]?.toIntOrNull() ?: 5
        logger.debug {
            "Creating new VideoPreviewExporter with maxSideResolution=$maxSideResolution mimeType=$mimeType, and previewTimeSec=$previewTimeSec."
        }
        return Instance(input, context, resolverName, maxSideResolution, mimeType, previewTimeSec, name)
    }

    /** The [Exporter] generated by this [VideoPreviewExporter]. */
    private class Instance(
        override val input: Operator<Retrievable>,
        private val context: Context,
        resolverName: String,
        private val maxResolution: Int,
        private val mimeType: MimeType,
        private val previewTimeSec: Int,
        override val name: String
    ) : Exporter {
        init {
            require(mimeType in SUPPORTED) {
                "VideoPreviewExporter only supports image formats JPEG and PNG."
            }
        }

        /** [Resolver] instance. */
        private val resolver: Resolver = this.context.resolver[resolverName]
            ?: throw IllegalStateException("Unknown resolver with name $resolverName.")


        override fun toFlow(scope: CoroutineScope): Flow<Retrievable> = this.input.toFlow(scope).onEach { retrievable ->
            val source = retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach
            if (source.type == MediaType.VIDEO) {
                val resolvable = this.resolver.resolve(retrievable.id, ".${this.mimeType.fileExtension}")
                if (resolvable != null) {
                    val writer = when (mimeType) {
                        MimeType.JPEG,
                        MimeType.JPG -> JpegWriter()

                        MimeType.PNG -> PngWriter()
                        else -> throw IllegalArgumentException("Unsupported mime type $mimeType")
                    }

                    logger.debug {
                        "Generating preview thumbnail for ${retrievable.id} with ${retrievable.type} and resolution $maxResolution. Storing it with ${resolvable::class.simpleName}."
                    }

                    source.newInputStream().use { input ->
                        val frame = getFrameAtSecond(input, previewTimeSec)
                        val imgBytes = ImmutableImage.fromAwt(frame).let {
                            if (it.width > it.height) {
                                it.scaleToWidth(maxResolution)
                            } else {
                                it.scaleToHeight(maxResolution)
                            }
                        }.bytes(writer)

                        resolvable.openOutputStream().use { output ->
                            output.write(imgBytes)
                        }
                    }
                }
            }
        }

        /**
         * Extracts a frame from the video at the specified second.
         *
         * @param input The [InputStream] representing the vide file.
         * @param second The second at which to extract the frame.
         * @return The extracted frame as a BufferedImage.
         */
        private fun getFrameAtSecond(input: InputStream, second: Int): BufferedImage {
            FFmpegFrameGrabber(input).use { grabber ->
                grabber.start()
                val frameRate = grabber.frameRate
                grabber.frameNumber = (frameRate * second).toInt()

                val frame = grabber.grabImage() ?: throw IllegalStateException("Could not grab frame from video.")

                val img = try {
                    PointerScope().use { scope ->
                        val c = Java2DFrameConverter()
                        c.convert(frame)
                    }
                } catch (e: Exception) {
                    logger.error(e) { "Error converting frame to BufferedImage" }
                    null
                }

                grabber.stop()
                return img!!
            }
        }
    }
}
