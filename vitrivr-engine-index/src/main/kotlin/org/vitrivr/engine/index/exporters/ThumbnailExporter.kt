package org.vitrivr.engine.index.exporters

import com.sksamuel.scrimage.ImmutableImage
import com.sksamuel.scrimage.nio.JpegWriter
import com.sksamuel.scrimage.nio.PngWriter
import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.vitrivr.engine.core.context.Context
import org.vitrivr.engine.core.model.content.element.ImageContent
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.OperatorFactory
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.resolver.Resolver
import org.vitrivr.engine.core.source.file.MimeType
import kotlin.text.toIntOrNull
import kotlin.text.uppercase

/**
 * An [Exporter] that generates thumbnails from videos and images.
 *
 * @author Finn Faber
 * @version 1.1.0
 */
class ThumbnailExporter : OperatorFactory {
    companion object {
        val SUPPORTED = setOf(MimeType.JPEG, MimeType.JPG, MimeType.PNG)
    }

    /**
     * Creates a new [Instance] instance from this [ThumbnailExporter].
     *
     * @param name the name of the [ThumbnailExporter.Instance]
     * @param inputs Map of named input [Operator]s
     * @param context The [Context] to use.
     */
    override fun newOperator(name: String, inputs: Map<String, Operator<out Retrievable>>, context: Context): Operator<out Retrievable> {
        require(inputs.size == 1)  { "The ${this::class.simpleName} only supports one input operator. If you want to combine multiple inputs, use explicit merge strategies." }
        val resolverName = context[name, "resolver"] ?: "default"
        val maxSideResolution = context[name, "maxSideResolution"]?.toIntOrNull() ?: 400
        val mimeType = context[name, "mimeType"]?.let {
            try {
                MimeType.valueOf(it.uppercase())
            } catch (e: java.lang.IllegalArgumentException) {
                null
            }
        } ?: MimeType.JPG
        return Instance(name, inputs.values.first(), context, resolverName, maxSideResolution, mimeType)
    }

    /**
     * The [Exporter] generated by this [ThumbnailExporter].
     */
    private class Instance(
        override val name: String,
        override val input: Operator<out Retrievable>,
        private val context: Context,
        resolverName: String,
        private val maxResolution: Int,
        private val mimeType: MimeType
    ) : Exporter {
        init {
            require(mimeType in SUPPORTED) { "ThumbnailExporter only support image formats JPEG and PNG." }
        }

        /** [Resolver] instance. */
        private val resolver: Resolver = this.context.resolver[resolverName]
            ?: throw IllegalStateException("Unknown resolver with name $resolverName.")

        /** [KLogger] instance. */
        private val logger: KLogger = KotlinLogging.logger {}

        override fun toFlow(scope: CoroutineScope): Flow<Retrievable> = this.input.toFlow(scope).onEach { retrievable ->
            try {
                val resolvable = this.resolver.resolve(retrievable.id, this.mimeType.fileExtension)
                val content = retrievable.content.filterIsInstance<ImageContent>()
                if (resolvable != null && content.isNotEmpty()) {
                    val writer = when (mimeType) {
                        MimeType.JPEG,
                        MimeType.JPG -> JpegWriter()

                        MimeType.PNG -> PngWriter()
                        else -> throw IllegalArgumentException("Unsupported mime type $mimeType")
                    }

                    logger.debug { "Generating thumbnail(s) for ${retrievable.id} with ${retrievable.type} and resolution $maxResolution. Storing it with ${resolvable::class.simpleName}." }

                    content.forEach { cnt ->
                        val imgBytes = ImmutableImage.fromAwt(cnt.content).let {
                            if (it.width > it.height) {
                                it.scaleToWidth(maxResolution)
                            } else {
                                it.scaleToHeight(maxResolution)
                            }
                        }.bytes(writer)

                        resolvable.openOutputStream().use {
                            it.write(imgBytes)
                        }
                    }
                }
            } catch (e: Exception) {
                logger.error(e) { "Error during thumbnail creation" }
            }
        }
    }
}

